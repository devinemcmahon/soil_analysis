# some functions to make the data usable
# Many of these are from the original process of compiling the data and are 
#   not necessary for analysis; just examples of code (maybe not good ones)

# Read in the data from the text files generated by Xlabpro (XRF software)
myreader=function(mystring){
  filename=paste(as.character(mystring),'txt',sep='.')
  read.table(filename,header=TRUE,skip=1,
             sep='\t',as.is=T)
}

# Remove unneeded columns
cleanuptxt=function(dfr){
  dfr=dfr[-which(dfr$Element=='Dimension'),]
  dfr=dfr[,-which(names(dfr)=='X')]
  dfr
}

# Rename the duplicate columns from the XRF software output
# Each element has columns for error, intensity (of the fluorescence) and
#   detection limit 
renamer=function(x){
  chr=as.character(x)
  chr=gsub(".1","_err",chr)
  chr=gsub(".2","_int",chr)
  chr=gsub(".3","_dl",chr)
  chr
}

# Replace values below detection limit with "NA" (no data)
#   and make numeric columns numeric
makenumeric=function(x){
  x[which(grepl('<',as.character(x),fixed=TRUE)==TRUE)]=NA
  x=as.numeric(as.character(x))
  x
}

# Remove typos from the ID column
# Some typos (mostly missing periods) were fixed by hand
typofixer=function(x){
  x=as.character(x)
  x=gsub('Bo','BO',x,fixed=T)
  x=gsub('BP','Bp',x,fixed=T)
  x=gsub(' It','It',x,fixed=T)
  x=gsub('Vq','Vg',x,fixed=T)
  x=gsub('Jp','JP',x,fixed=T)
  x=gsub('Sp','5',x,fixed=T) # soil pit = rep 5
  x=gsub('PIT','5',x,fixed=T)
  x=gsub('EU','Eu',x,fixed=T)
  x=gsub('IT','It',x,fixed=T)
  x=gsub('A.E1','A.E',x,fixed=T)
  x=gsub('A.L1','A.L',x,fixed=T)
  x
}

# split the ID column into its components
strfun=function(dat){
  # Split the ID column into its constituent parts, separated by periods
  strs=strsplit(as.character(dat$ID),'[.]')
  
  # The first element of each ID is the site
  dat$site=as.character(lapply(strs,function(L){L[1]}))
  dat$site=as.factor(dat$site)
  
  # The second element is the land use (Euc, Pasture, Native, Abandoned)
  dat$LU=as.character(lapply(strs,function(L){L[2]}))
  dat$stand=as.factor(paste(dat$site,dat$LU,sep='.'))
  dat$LU[dat$LU %in% c('E1','E2')]='E'
  dat$LU[dat$LU %in% c('A1','A2')]='A'
  dat$LU=factor(dat$LU,levels=unique(dat$LU))
  
  # The third element will be row position, if there is one
  dat$position=as.factor(as.character(lapply(strs,function(L){L[3]})))
  # If there is no position number, the third element of the string
  #	will be the repetition number; replace those with NAs	
  dat$position[dat$position %in% c('1','2','3','4','5')]=NA
  
  # The last element is the year
  dat$year=as.factor(as.character(lapply(strs,function(L){L[length(L)]})))
  
  # The third-to-last element is the repetition number
  dat$rep=as.numeric(as.character(lapply(strs,
                                         function(L){L[length(L)-2]})))
  
  # The second-to-last element is the depth increment, which has two parts
  deps=as.character(lapply(strs,function(L){L[length(L)-1]}))
  depstr=strsplit(deps,'-')
  depstr1=as.numeric(as.character(lapply(depstr,function(L){L[1]})))
  depstr2=as.numeric(as.character(lapply(depstr,function(L){L[2]})))
  dat$inc_from=depstr1
  dat$inc_to=depstr2
  dat$depth=(dat$inc_from+dat$inc_to)/2
  return(dat)
}
# A simpler 'position' column
eltfun=function(dat){
  dat$elt=dat$position
  dat$elt[dat$position=='Ee1' | dat$position=='Ee2' |
            dat$position=='Ee']='E'
  dat$elt=droplevels(dat$elt)
  dat
}

# Put the date of XRF analysis in date format
strdate=function(x){
  strs=strsplit(as.character(x),' ')
  thedate=as.Date(as.character(lapply(strs,function(L){L[1]})),'%m/%d/%Y')
  thedate
}

xrffun=function(dfr){
  betternames=renamer(names(dfr))
  names(dfr)=betternames
  names(dfr)[names(dfr)=='Element']='ID'
  dfr$ID=typofixer(dfr$ID)
  dfr1=dfr[,(1:3)]
  #dfr1=dfr1[,-which(names(dfr1)=='Description')] # already done
  # don't make the ID, Method, and Date columns numeric
  dfr2=as.data.frame(lapply(dfr[,-(1:4)],makenumeric))
  newdfr=cbind(dfr1,dfr2)
  newdfr=strfun(newdfr)
  newdfr=eltfun(newdfr)
  mydates=strdate(newdfr$Eval.Date)
  newdfr$evaldate=mydates
  newdfr
}

# When reading in a .csv, make the year '04' into a factor
# rather than the number 4
yrfactorer=function(dfr){
  dfr$year=as.character(dfr$year)
  dfr$year[dfr$year=='4']='04'
  if(is.element('measured_in',names(dfr))){
    dfr$measured_in=as.character(dfr$measured_in)
  }
  if(is.element('measured_in',names(dfr))){
    dfr$measured_in[dfr$measured_in=='4']='04'
  }
  dfr
}
